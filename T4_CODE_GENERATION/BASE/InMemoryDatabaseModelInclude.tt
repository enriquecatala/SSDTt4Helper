<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".dsql" #>
/* Generated by InMemoryDatabaseModelInclude.tt downloaded from https://github.com/enriquecatala/SSDTt4Helper */
/* Copyright (c) 2020 Enrique Catalá Bañuls */
<#@ SqlModelDirective processor="SqlModelDirectiveProcessor" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime.Serialization" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="$(MSBuildExtensionsPath)\..\Common7\IDE\Extensions\Microsoft\SQLDB\DAC\150\Microsoft.SqlServer.TransactSql.ScriptDom.dll" #>
<#@ assembly name="$(MSBuildExtensionsPath)\..\Common7\IDE\Extensions\Microsoft\SQLDB\DAC\150\Microsoft.SqlServer.Dac.dll" #>
<#@ assembly name="$(MSBuildExtensionsPath)\..\Common7\IDE\Extensions\Microsoft\SQLDB\DAC\150\Microsoft.SqlServer.Dac.Extensions.dll" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="Microsoft.SqlServer.Dac" #>
<#@ import namespace="Microsoft.SqlServer.Dac.Model" #>
<#@ import namespace="System.Runtime.Serialization" #>
<#@ import namespace="System.Runtime.Serialization.Json" #>

<#+
	/* 
	 * CHANGELOG:
	 * =========
	 *   Enrique Catala [10-01-2017] Added support for:
	 *       -VS2019 support
	 *		 -bug fixes
	 *       -deleted reference to old https://T4DacFx2TSQL.codeplex.com
	 *
	 *   Enrique Catala [10-01-2017] Added support for:
	 *       -VS2017 support
	 *		 -bug fixes
	 *       -Polybase demo
	 *
	 *   Enrique Catala [30-05-2016] Added support for:
	 *       -SQL Server 2014 libraries and VS2015
	 *		 -JSON table filtering
	 *
	 *   Dr. John Tunnicliffe:
	 *		 -Initial version
	 *         	 
	 * Enrique Catalá Bañuls:        https://www.linkedin.com/in/enriquecatala/
	 * Microsoft Data Platform MVP:  https://mvp.microsoft.com/es-es/PublicProfile/5000312?fullName=Enrique%20Catala
 	 * Blog:                         http://www.enriquecatala.com
	 * Twitter:                      https://twitter.com/enriquecatala
	 *
	 * With credit to John Tunnicliffe and Dave Ballantyne and Geoff Clark for their initial code samples.
	 *
	 * The MIT License (MIT)
	 * Copyright (c) 2015 Dr. John Tunnicliffe, Decision Analytics, London, UK
	 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
	 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */


	// To return the solution directory of this project. 
	// NOTE: You can use Host.ResolvePath("") to get the "Project" path
	//
	public string GetSolutionDirectory()
	{
		var serviceProvider = this.Host as IServiceProvider;
		var dte = serviceProvider.GetService(typeof(EnvDTE.DTE)) as EnvDTE.DTE;
		return System.IO.Path.GetDirectoryName(dte.Solution.FullName);
	}

	// simply returns all tables in the model
    public List<TSqlObject> GetAllTables(TSqlModel model)
    {
		// returns a list of all tables in the model
        List<TSqlObject> allTables = new List<TSqlObject>();
 
        var tables = model.GetObjects(DacQueryScopes.All, ModelSchema.Table);
        if (tables != null)
        {
			allTables.AddRange(tables);
        }

        return allTables;
    }

	// This is a more generic version of the above GetAllTables as it simply returns all objects of the specified type in the model
	// A full list of ModelTypeClass can be found here https://msdn.microsoft.com/en-us/library/microsoft.sqlserver.dac.model.modelschema
	// and should be written in the form: ModelSchema.XXX e.g. ModelSchema.Table
    public List<TSqlObject> GetAllObjectsOfSpecifiedType(TSqlModel model, ModelTypeClass dbObjectType)
    {
		// returns a list of all tables in the model
        List<TSqlObject> allObjects = new List<TSqlObject>();
		
		// we only want UserDefined database objects 
        var tables = model.GetObjects(DacQueryScopes.UserDefined, dbObjectType);
        if (tables != null)
        {
			allObjects.AddRange(tables);
        }

        return allObjects;
    }

	// returns all tables in a specific schema and, optionally, with one of the prefixes passed in the list
    public List<TSqlObject> GetAllTablesInSchemaWithPrefixes(TSqlModel model, string schemaName, string[] prefixes)
    {
		// returns just the tables that we want to add history tables
		// as this demo uses the AdventureWorks database, we are selecting the dbo schema, 
		// in a real example, you would select your specific schema
        List<TSqlObject> allTables = new List<TSqlObject>();
 
        var tables = model.GetObjects(DacQueryScopes.All, ModelSchema.Table);
        if (tables != null)
        {
            foreach (var table in tables)
            {
				// select only those tables we want from the relevant schema
                if (table.Name.Parts[0].ToString().ToLower() == schemaName.ToLower())
                {
					// if we have a list of prefixes, check they match the first few characters in the table name 
					if (prefixes != null)
                    {
						foreach (string prefix in prefixes)
                        {
							if (table.Name.Parts[1].StartsWith(prefix, StringComparison.CurrentCultureIgnoreCase))
                            {
								allTables.Add(table);
								break;
                            }
                        }
                    }
					else
                    {
						allTables.Add(table);
                    }
                } 
            }
        }

        return allTables;
    }

	
	


	// returns all tables in a specific schema
	public List<TSqlObject> GetAllTablesInSchema(TSqlModel model, string schemaName)
    {
		return GetAllTablesInSchemaWithPrefixes(model, schemaName, null);
    }

	
	// Same as GetAllTablesInSchemaWithPrefixes but more generic as it returns all objects of the specified type in a specific schema and, optionally, with one of the prefixes passed in the list
	// A full list of ModelTypeClass can be found here https://msdn.microsoft.com/en-us/library/microsoft.sqlserver.dac.model.modelschema
	// and should be written in the form: ModelSchema.XXX e.g. ModelSchema.Table
    public List<TSqlObject> GetAllObjectsInSchemaWithPrefixes(TSqlModel model, ModelTypeClass dbObjectType, string schemaNameToMatch, string[] prefixes)
    {
		// returns just the tables that we want to add history tables
		// as this demo uses the AdventureWorks database, we are selecting the dbo schema, 
		// in a real example, you would select your specific schema
        List<TSqlObject> filteredObjects = new List<TSqlObject>();
 
        var objects = model.GetObjects(DacQueryScopes.UserDefined, dbObjectType);
        if (objects != null)
        {
            foreach (var obj in objects)
            {
				// select only those tables we want from the relevant schema
                if (obj.Name.Parts[0].ToString().ToLower() == schemaNameToMatch.ToLower())
                {
					// if we have a list of prefixes, check they match the first few characters in the obj name 
					if (prefixes != null)
                    {
						foreach (string prefix in prefixes)
                        {
							if (obj.Name.Parts[1].StartsWith(prefix, StringComparison.CurrentCultureIgnoreCase))
                            {
								filteredObjects.Add(obj);
								break;
                            }
                        }
                    }
					else
                    {
						filteredObjects.Add(obj);
                    }
                } 
            }
        }
		
        return filteredObjects;
    }

	// Same as GetAllObjectsInSchemaWithPrefixes but does not require a list of prefixes
	public List<TSqlObject> GetAllObjectsInSchema(TSqlModel model, ModelTypeClass dbObjectType, string schemaNameToMatch)
    {
		return GetAllObjectsInSchemaWithPrefixes(model, dbObjectType, schemaNameToMatch, null);
    }

	/// Returns a list of columns which form the primary key collection for the table
	public List<TSqlObject> GetPrimaryKeyColumns(TSqlObject table)
    {
		List<TSqlObject> columns = new List<TSqlObject>();

		// find the primary key constraint for the table		
		// we have to iterate through the children as Linq throws an error which we cannot catch if no PrimaryKeyConstraint exists
		foreach (var child in table.GetChildren())
		{
			if (child.ObjectType.Name == "PrimaryKeyConstraint")
            {
				foreach (TSqlObject column in child.GetReferenced(DacQueryScopes.UserDefined).Where(x => x.ObjectType.Name == "Column"))
				{
					columns.Add(column);
				}
			} 
			
		}		
		return columns;
    }      

    // Returns true if the column is part of primary key
	public bool ColumnIsPartOfPrimaryKey(List<TSqlObject> primaryKeyColumns,TSqlObject c)
	{
		bool retorno = false;
		//System.Diagnostics.Debugger.Launch();
		foreach (var column in primaryKeyColumns)
		{ 		
		   if (column.Name.Parts[2] == c.Name.Parts[2])
		   {
		   	 retorno = true;
			 break;
		   }
		}
		return (retorno);
	}

	/// Returns a list of ModelRelationshipInstance objects representing all the foreign key relationships
	public List<ModelRelationshipInstance> GetForeignKeyColumns(TSqlObject table)
    {
		List<ModelRelationshipInstance> foreignKeyRelationship = new List<ModelRelationshipInstance>();
		
		// find the primary key constraint for the table
		// we have to iterate through the children as Linq throws an error which we cannot catch if no PrimaryKeyConstraint exists
		foreach (var child in table.GetChildren())
		{
			if (child.ObjectType.Name == "PrimaryKeyConstraint")
            {
				foreach (TSqlObject column in child.GetReferenced(DacQueryScopes.UserDefined).Where(x => x.ObjectType.Name == "Column"))
				{
					foreach (ModelRelationshipInstance refRel in column.GetReferencingRelationshipInstances())
					{
						if (refRel.Relationship.Name == "ForeignColumns")                     {
							foreignKeyRelationship.Add(refRel);
						}
					}
				}			
            }
        }
		return foreignKeyRelationship;
    }      
	
	// Return true if the tables has an IDENTITY
	public bool HasIdentityColumn(TSqlObject table)
	{
		bool retorno = false;
		//System.Diagnostics.Debugger.Break();
		foreach (var column in table.GetReferenced(Table.Columns))
		{ 		
		    //https://github.com/microsoft/DACExtensions/blob/master/DacFxStronglyTypedModel/model.cs
			if(column.GetProperty<Boolean>(Column.IsIdentity)==true)
			{
				retorno=true;
				break;
			}
		}
		return (retorno);
	}

	/// Returns the list of identity columns for the table
	public List<TSqlObject> GetIdentityColumns(TSqlObject table)
    {
		List<TSqlObject> columns = new List<TSqlObject>();
				
		//System.Diagnostics.Debugger.Break();
		foreach (var column in table.GetReferenced(Table.Columns))
		{ 		
		    //https://github.com/microsoft/DACExtensions/blob/master/DacFxStronglyTypedModel/model.cs
			if(column.GetProperty<Boolean>(Column.IsIdentity)==true)
			{
				columns.Add(column);
			}
		}
		
		return columns;
    }  

	// Returns true if the column is part of identity columns
	public bool ColumnIsPartOfIdentityColumns(TSqlObject table,TSqlObject c)
	{
		bool retorno = false;
		//System.Diagnostics.Debugger.Launch();
		foreach (var column in table.GetReferenced(Table.Columns))
		{ 		
		   if((column.GetProperty<Boolean>(Column.IsIdentity)==true) 
				&& (column.Name.Parts[2] == c.Name.Parts[2]))
		   {
		   	 retorno = true;
			 break;
		   }
		}
		return (retorno);
	}

	// Returns the column definition in the format expected by SQL CREATE TABLE scripts
    public string GetColumnDefinition(TSqlObject column)
    {
	    // first add the column name 
        string cName = "[" + column.Name.Parts[2] + "] " ;		

		if (column.GetReferenced(Column.DataType).Count()==0)
		{			
			return "--"+cName + " is a computed column";			
		}

		var tmp = column.GetReferenced(Column.DataType).First();		        
		
		if (tmp.ObjectType.Name != "DataType")
		{
		    cName+=" is a "+ tmp.ObjectType.Name+ " and must be FIXED MANUALLY!! ";
			return cName;
		}

        SqlDataType sdt = column.GetReferenced(Column.DataType).First().GetProperty<SqlDataType>(DataType.SqlDataType);

		// first add the column name and data type
        string columnDef = "[" + column.Name.Parts[2] + "] " + sdt.ToString().ToUpper();
		

		// get some properties which we append to the string dependent upon 
        bool isNullable = (bool)column.GetProperty(column.ObjectType.Properties.Where(p => p.Name == "Nullable").First());
        int precision = (int)column.GetProperty(column.ObjectType.Properties.Where(p => p.Name == "Precision").First());
        int scale = (int)column.GetProperty(column.ObjectType.Properties.Where(p => p.Name == "Scale").First());
        int length = (int)column.GetProperty(column.ObjectType.Properties.Where(p => p.Name == "Length").First());
        
        switch (sdt.ToString().ToUpper())
        {
            case "CHAR":
            case "VARCHAR":
            case "NCHAR":
            case "NVARCHAR":
				if (length == 0)
					columnDef += "(MAX)";
				else
					columnDef += "(" + length.ToString() + ")";
                break;
            case "FLOAT":
            case "REAL":
            case "DATETIME2":
                columnDef += "(" + precision.ToString() + ")";
                break;
            case "DECIMAL":
            case "NUMERIC":
                columnDef += "(" + precision.ToString() + "," + scale.ToString() + ")";
                break;
            default:
				// don't add anything extra to other data types
                break;
        }
        
        if (!isNullable) 
            columnDef += " NOT NULL";

        return columnDef;
    }

	// Returns the column definition with only the data type ( id_column decimal(10,2) for example (does not includes the NULLABLE, identity,...))
	// For more detailed info, please use the method GetColumnDefinition
	//
	public string GetColumnWithDataTypeOnly(TSqlObject column)
    {
	    // first add the column name 
        string cName = "[" + column.Name.Parts[2] + "] " ;		

		if (column.GetReferenced(Column.DataType).Count()==0)
		{			
			return "--"+cName + " is a computed column";			
		}

		var tmp = column.GetReferenced(Column.DataType).First();		        
		
		if (tmp.ObjectType.Name != "DataType")
		{
		    cName+=" ["+ tmp.ObjectType.Name+ "]";
			return cName;
		}

        SqlDataType sdt = column.GetReferenced(Column.DataType).First().GetProperty<SqlDataType>(DataType.SqlDataType);

		// first add the column name and data type
        string columnDef = "[" + column.Name.Parts[2] + "] " + sdt.ToString().ToUpper();
		

		// get some properties which we append to the string dependent upon 
        int precision = (int)column.GetProperty(column.ObjectType.Properties.Where(p => p.Name == "Precision").First());
        int scale = (int)column.GetProperty(column.ObjectType.Properties.Where(p => p.Name == "Scale").First());
        int length = (int)column.GetProperty(column.ObjectType.Properties.Where(p => p.Name == "Length").First());
        
        switch (sdt.ToString().ToUpper())
        {
            case "CHAR":
            case "VARCHAR":
            case "NCHAR":
            case "NVARCHAR":
				if (length == 0)
					columnDef += "(MAX)";
				else
					columnDef += "(" + length.ToString() + ")";
                break;
            case "FLOAT":
            case "REAL":
            case "DATETIME2":
                columnDef += "(" + precision.ToString() + ")";
                break;
            case "DECIMAL":
            case "NUMERIC":
                columnDef += "(" + precision.ToString() + "," + scale.ToString() + ")";
                break;
            default:
				// don't add anything extra to other data types
                break;
        }
        
        return columnDef;
    }

	// Simply returns the column name
    public string GetColumnName(TSqlObject column)
    {
        return column.Name.Parts[2];
    }
 
 
	// Builds an in-memory database model of what is in the current project
	public TSqlModel GetInMemoryDatabaseModel()
    {
		// create a new empty model 
		TSqlModel model = new TSqlModel(SqlServerVersion.Sql120, new TSqlModelOptions { });

		// obtain a reference to the host provider which is processing the T4 template
		var hostServiceProvider = (IServiceProvider)this.Host;
		var dte = (DTE)hostServiceProvider.GetService(typeof(DTE));
 
		// find the current project using the T4 template we are building
		EnvDTE.ProjectItem containingProjectItem = dte.Solution.FindProjectItem(Host.TemplateFile);		
		Project currentProject = containingProjectItem.ContainingProject;
		// Con esto funciona cuando da error de deserializacion en el paso anterior
		//Project currentProject = dte.Solution.Projects.Item(1);  

		BuildInMemoryModelFromScripts(currentProject.ProjectItems, model);
        
		return model;
    }
 
    private void BuildInMemoryModelFromScripts(ProjectItems prjItems, TSqlModel model)
    {
        foreach(ProjectItem prjItem in  prjItems)
        {
            if(prjItem.Name.EndsWith(".tt", StringComparison.OrdinalIgnoreCase))
			{ 
				// Don't Load the files we are building!
                continue;
            }

            if(prjItem.ProjectItems!=null)
            {
                BuildInMemoryModelFromScripts(prjItem.ProjectItems, model);
            }

            if(prjItem.Name.EndsWith(".sql", StringComparison.OrdinalIgnoreCase))
            {
				// ensure the item is saved to disk
                if (!prjItem.Saved)
                {
                    prjItem.Save();
                } 

				// Only process scripts marked with "Build"
				if (prjItem.Properties.Item("BuildAction").Value.ToString()== "Build")
				{
					// now read the script and add it to the in-memory model
					StreamReader reader = new StreamReader(prjItem.FileNames[0]);
					string script = reader.ReadToEnd();
					try
					{					 
						 model.AddObjects(script);
					}
					catch(Exception e)
					{
					      // If you have the template debug="true" flag, this will pop up the debugger
						  System.Diagnostics.Debugger.Launch();
					}
				}				
			}
        }
    }

	// returns the columns, excluding both sync columns ([$sb_node] ,[$sb_rownum])	
	//
	public string GetColumnsWithDataType(TSqlObject table)
	{
		int i=0;
		string retorno = String.Empty;
   		foreach (var column in table.GetReferenced(Table.Columns))
		{ 				     
			
			string columna = String.Empty;
			string columnaName = String.Empty;
			if(i==0)
			{
				columna = GetColumnWithDataTypeOnly(column);                					
			}
			else
			{
				columna = ","+GetColumnWithDataTypeOnly(column);					
			}
			retorno +=columna;				
			i++;
			
		}
		return(retorno);
	}

	// returns the columns
	//
	public string GetColumnsWithoutDataType(TSqlObject table)
	{
		int i=0;
		string retorno= String.Empty;
   		foreach (var column in table.GetReferenced(Table.Columns))
		{ 				     
			
			string columnaName = String.Empty;
			if(i==0)
			{
				columnaName = "[" + column.Name.Parts[2] + "] ";
			}
			else
			{
				columnaName = ", [" + column.Name.Parts[2] + "] ";
			}
				
			retorno+=columnaName;
			i++;
			
		}
		return(retorno);
	}

	#region In-Memory model only with the filtered objects

	// Base class that will help filtering objects based on a JSON
    //
    [DataContract(Name = "ObjectToAnalyze")]
    public class ObjectToAnalyze
    {
		public ObjectToAnalyze(string schema, string name){Schema = schema; Name = name;}
        [DataMember(Name="schema")]
        public string Schema { get;
            set; }
        [DataMember(Name="name")]
        public string Name { get;
            set; }
    }

	public List<TSqlObject> GetAllTablesFromList(TSqlModel model, List<ObjectToAnalyze> auditingTables)
    {
		// returns just the tables that we want to add history tables
		// as this demo uses the AdventureWorks database, we are selecting the dbo schema, 
		// in a real example, you would select your specific schema
        List<TSqlObject> allTables = new List<TSqlObject>();
 
        var tables = model.GetObjects(DacQueryScopes.All, ModelSchema.Table);
        if (tables != null)
        {
            foreach (var table in tables)
            {
				ObjectToAnalyze ta = new ObjectToAnalyze(table.Name.Parts[0],table.Name.Parts[1]);

				 var lst = auditingTables.Find(x => x.Schema.ToLower() == ta.Schema.ToLower() && x.Name.ToLower() == ta.Name.ToLower());

				 if(lst!=null)
					 allTables.Add(table);				
                 
            }
        }

        return allTables;
    }


	// Builds an in-memory database model containing only the files specified at the JSON file
	// This is very important when you only want to generate a few objects from a big model
	// Example: 
	//      Without filtering (calling GetInMemoryDatabaseModel()) the parsing of 11000 .sql files is 10 minutes on
	//   an Intel i7-4710 (2.5Ghz)
	//      Filtering (calling GetInMemoryDatabaseModel(List<ObjectToAnalyze> objects_to_process)) the same parsing 
	//   takes ONLY 5s
	//
	public TSqlModel GetInMemoryDatabaseModel(List<ObjectToAnalyze> objects_to_process)
    {
		// create a new empty model 
		TSqlModel model = new TSqlModel(SqlServerVersion.Sql120, new TSqlModelOptions { });

		// obtain a reference to the host provider which is processing the T4 template
		var hostServiceProvider = (IServiceProvider)this.Host;
		var dte = (DTE)hostServiceProvider.GetService(typeof(DTE));
 
		// find the current project using the T4 template we are building
		EnvDTE.ProjectItem containingProjectItem = dte.Solution.FindProjectItem(Host.TemplateFile);		
		Project currentProject = containingProjectItem.ContainingProject;
		// Con esto funciona cuando da error de deserializacion en el paso anterior
		//Project currentProject = dte.Solution.Projects.Item(1);  
		//System.Diagnostics.Debugger.Break();
		BuildInMemoryModelFromScripts(currentProject.ProjectItems, model,objects_to_process);
        
		return model;
    }

	private void BuildInMemoryModelFromScripts(ProjectItems prjItems, TSqlModel model,List<ObjectToAnalyze> objects_to_process)
    {
        foreach(ProjectItem prjItem in  prjItems)
        {
		
			if(prjItem.ProjectItems!=null)
            {
                BuildInMemoryModelFromScripts(prjItem.ProjectItems, model,objects_to_process);
            }

			// fist of all we check if the file name contains the name of the object
			//
			//System.Diagnostics.Debugger.Launch();
			var lst = objects_to_process.Find(x => prjItem.Name.ToLower().Contains(x.Name.ToLower()));
			if(lst==null)			
			{			
				continue;
			}
			
            if(prjItem.Name.EndsWith(".tt", StringComparison.OrdinalIgnoreCase))
			{ 
				// Don't Load the files we are building!
                continue;
            }

         

            if(prjItem.Name.EndsWith(".sql", StringComparison.OrdinalIgnoreCase))
            {
				// ensure the item is saved to disk
                if (!prjItem.Saved)
                {
                    prjItem.Save();
                }				
				// now read the script and add it to the in-memory model
                StreamReader reader = new StreamReader(prjItem.FileNames[0]);
                string script = reader.ReadToEnd();
				try
				{
                model.AddObjects(script);
				}
				catch(Exception e)
				{
				System.Diagnostics.Debugger.Launch();
				throw e;
				}
            }
        }
    }

	// returns primary key columns comma separated values
	//
	public string GetColumnsCommaSeparatedString(List<TSqlObject> columns)
	{
		string retorno = String.Empty;
		int i=0;
		//System.Diagnostics.Debugger.Launch();
		foreach (var column in columns)
		{ 		
		    if(i==0)
			{
			   retorno = String.Format("[{0}] ",column.Name.Parts[2]);
			}
			else
			{
			   retorno += String.Format(",[{0}] ",column.Name.Parts[2]);
			}
			i++;
		}
		return (retorno);
	}

	// returns columns with metadata  comma separated values
	//
	public string GetColumnsWithDataTypeCommaSeparatedString(List<TSqlObject> columns)
	{
          string retorno = String.Empty;
          int i=0;
   		  foreach (var column in columns)
		  { 				     
			if(i==0)
            {
				retorno = GetColumnWithDataTypeOnly(column);                                
            }
			else
            {
				retorno += ","+GetColumnWithDataTypeOnly(column);
            }
            i++;
		  }
		return (retorno);
	}

	#endregion
#>
